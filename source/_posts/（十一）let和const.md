---
title: （十一）let和const
date: 2019-12-21 20:32:15
tags: ECMAScript 6
---
# let和const

## 基本用法

let用于定义一个变量，用法与var类似，let定义的变量只在代码块内有效。

for循环的循环变量很适合使用let定义。

for循环有一个特别之处，就是设置循环变量的是一个父作用域，而循环体内部是一个子作用域。

例子如下：

```js
for (var i = 0; i < 5; i++) {
      var i = 'abc';
      console.log(i);
    }

    for (let i = 0; i < 5; i++) {
      let i = 'abc';
      console.log(i);
    }
```

使用var定义的循环变量的循环只会执行一次，输出一次'abc'，说明循环体内改变了循环变量。

使用let定义的循环变量的循环会执行五次，输出五次'abc'，说明循环体内的变量没有被改变。

## 变量提升

使用var定义的变量会有变量提升出现，意思是变量没有声明就直接使用，这种现象对let不适用，如果没有定义就直接使用会报错。

## 暂时性死区

只要块级作用域存在了let命令，它所声明的变量就绑定了这块区域，不再受外部影响。

看如下代码：

```js
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```

暂时性死区（TDZ），let变量在声明之前，这个变量都是不可用的，在语法上称之为暂时性死区。

在暂时性死区的时候，不可以使用typeof方法。否则会报引用错误。

```js
typeof x; // ReferenceError
let x;
```

如果一个变量没有被声明，使用typeof反而不会报错。

```js
typeof undeclared_variable // "undefined"
```

所以，typeof在没有let声明的时候是百分百安全的，但是使用了let声明就不一定了。这样设计的意思是让我们保持一个良好的编程习惯，变量在使用前一定要先声明。

总结，暂时性死区的本质是，只要已进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取该变量。

## 不允许重复声明

let不允许在相同作用域内，重复声明一个变量。

## 块级作用域与函数声明

函数能不能在块级作用域中声明，这是一个十分令人混淆的问题。

在ES5中规定，函数只能在顶层作用域或者函数作用域中声明，不能在块级作用域中声明。代码如下：

```js
// 情况一
if (true) {
  function f() {}
}

// 情况二
try {
  function f() {}
} catch(e) {
  // ...
}
```

所以按照ES5的规定，上述代码是错误的。

但是浏览器没有遵守这个规定，为了兼容以前的旧代码，上面代码实际使用时是不会报错的。

在ES6中引入了块级作用域，明确了块级作用域中可以声明函数。

## Const

const声明一个只读的常量，一旦声明，常量的值就不能改变。

const一但声明就必须赋值，不可以之后再赋值。

const声明的常量也是不提升，同样存在暂时性死区。

const声明的常量也不可以重复声明。

## 本质

const声明，并不是保证指向的值不变，而是保证指向值得指针不变。对于简单数据类型（数值，字符串，布尔值），他们的值就保存在指针指向的地址，相当于常量。而对于复合型数据（数组，对象）来说，const只能保证指针是固定的，而指针指向的数据是不是可变就不能控制了。代码如下：

```js
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
```

上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

另一个例子：

```js
const a = [];
a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错
```

如果真的想将对象冻结，应该使用Object.freeze方法。

```js
const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
```

## ES6的六种声明变量方法

+ var
+ function
+ let
+ const
+ import
+ class

## 顶层对象属性

ES5中，顶层对象的属性和全局变量时等价的。代码如下：

```js
window.a = 1;
a // 1

a = 2;
window.a // 2
```

也就是说顶层对象（浏览器中是window，node中是global）的属性赋值和全局变量的赋值是一回事。

这是JS设计的最大败笔之一。

原因有三：

+ 无法在编译时提出变量未声明的错误，因为全局变量可能是顶层对象的属性创建的。
+ 程序员可能不知不觉就创建了全局变量（打字出错）。
+ 顶层对象的属性是到处可读写的，不利于模块化开发。还有，window具有实体含义，指浏览器窗口，顶层对象具有实体意义，也是不合适的。

ES6为了改正这一点，一方面var和function创建的变量依旧是全局变量或者说顶层对象的属性，一方面let和const创建的全局变量不属于顶层对象的属性。代码如下：

```js
var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
```

## globalThis对象

JS语言是存在一个顶层对象的，它提供全局作用域（全局环境），所有的代码都是在这个环境中运行的，但是在不同的实现中，顶层对象又是不同的。

+ 浏览器中，顶层对象是window，但node和web worker中没有window。
+ 浏览器和web worker中self也指向顶层对象，但node中没有self。
+ node中，顶层对象是global，但其他环境都不支持。

而globalThis对象，在什么环境中，指向的都是顶层对象。

